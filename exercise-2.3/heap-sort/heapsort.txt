# \/ Heap sort NOT IN PLACE - Queue \/
class Queue:

    items = []

    def __init__(self):
        self.items = []

    def add(self, item: int) -> None:
        self.items.append(item)
        current_index = len(self.items) - 1
        parent = (current_index - 1) // 2
        if parent < 0:
            return
        while self.items[parent] < self.items[current_index]:
            self.items[parent], self.items[current_index] = (
                self.items[current_index],
                self.items[parent],
            )
            current_index = parent
            parent = (current_index - 1) // 2
            if current_index == 0 or parent < 0:
                break

    def remove(self) -> int:
        if self.size() == 0:
            raise Exception("Queue is empty")
        if self.size() == 1:
            return self.items.pop()
        current_root = self.items[0]
        last = self.items.pop()
        self.items[0] = last
        index = 0
        array_len = len(self.items)
        while index < array_len:
            left = 2 * index + 1
            right = 2 * index + 2

            if left < array_len and right < array_len:
                if (
                    self.items[left] >= self.items[right]
                    and self.items[left] >= self.items[index]
                ):
                    self.items[left], self.items[index] = (
                        self.items[index],
                        self.items[left],
                    )
                    index = left
                elif (
                    self.items[right] > self.items[left]
                    and self.items[right] > self.items[index]
                ):
                    self.items[right], self.items[index] = (
                        self.items[index],
                        self.items[right],
                    )
                    index = right
                else:
                    break
            elif left < array_len and self.items[left] >= self.items[index]:
                self.items[left], self.items[index] = (
                    self.items[index],
                    self.items[left],
                )
                index = left
            elif right < array_len and self.items[right] > self.items[index]:
                self.items[right], self.items[index] = (
                    self.items[index],
                    self.items[right],
                )
                index = right
            else:
                break
        return current_root

    def is_empty(self) -> bool:
        return len(self.items) == 0

    def size(self) -> int:
        return len(self.items)

    def peek(self) -> None | int:
        if self.is_empty():
            return None
        return self.items[0]

# /\ Heap sort NOT IN PLACE - Queue /\

# \/ Heap sort NOT IN PLACE \/

def heap_sort_not_in_place(arr):
    max_heap = Queue()

    for element in arr:
        max_heap.add(element)
    sorted_array = [0] * len(arr)
    for i in range(len(arr), 0, -1):
        sorted_array[i - 1] = max_heap.remove()
    return sorted_array

# /\ Heap sort NOT IN PLACE /\

# \/ Heap sort IN PLACE \/

def get_max(arr, left, right, n):
    if left >= n:
        return n
    if right >= n:
        return left
    return left if arr[left] > arr[right] else right


def max_heapify(arr, i, n):
    c = get_max(arr, 2 * i + 1, 2 * i + 2, n)
    while c < n and arr[i] < arr[c]:
        arr[i], arr[c] = arr[c], arr[i]
        i = c
        c = get_max(arr, 2 * i + 1, 2 * i + 2, n)


def build_max_heap(arr, n):
    for i in range((n - 1) // 2, -1, -1):
        max_heapify(arr, i, n)


def heap_sort(arr):
    n = len(arr)
    build_max_heap(arr, n)
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        max_heapify(arr, 0, i)
    return arr

# /\ Heap sort IN PLACE /\

# \/ Heap sort IN PLACE HEAP_Q \/

import heapq


def heapsort(arr):
    heapq.heapify(arr)
    sorted_array = []
    while arr:
        sorted_array.append(heapq.heappop(arr))
    return sorted_array

# /\ Heap sort IN PLACE HEAP_Q /\