// Dependencies functions:
def merge(
    a: list[int],
    b: list[int],
):

    max_len = len(a) + len(b)
    merged = []
    i, j = 0, 0

    while len(merged) < max_len:

        if i >= len(a):
            merged.append(b[j])
            j += 1
        elif j >= len(b):
            merged.append(a[i])
            i += 1
        else:
            if a[i] <= b[j]:
                merged.append(a[i])
                i += 1
            elif b[j] <= a[i]:
                merged.append(b[j])
                j += 1
    return merged

def lomuto_partition(
    items: list[int],
    left: int,
    right: int,
):
    pivot = items[right]
    i = left - 1

    for j in range(left, right):
        if items[j] <= pivot:
            i += 1
            items[i], items[j] = items[j], items[i]
    right_place = i + 1
    items[right_place], items[right] = items[right], items[right_place]
    return right_place

def haore_partition(items: list[int], start: int, pivot_index: int):

    pivot = items[pivot_index]
    right = pivot_index - 1
    left = start

    while left <= right:
        while left <= right and items[left] < pivot:
            left += 1
        while left <= right and items[right] > pivot:
            right -= 1
        if left <= right:
            items[left], items[right] = items[right], items[left]
            left += 1
            right -= 1
    items[left], items[pivot_index] = items[pivot_index], items[left]
    return left  # return the new pivot index


// Sorting algorithms:

def merge_sort(arr):
    arr_len = len(arr)
    if arr_len != 1:
        size = arr_len // 2
        start = arr[:size]
        end = arr[size:]
        return merge(merge_sort(start), merge_sort(end))
    return arr

def quick_haore(items: list[int], start: int, pivot_index: int):

    if start < pivot_index:
        split_index = haore_partition(items, start, pivot_index)

        quick_haore(items, start, split_index - 1)
        quick_haore(items, split_index + 1, pivot_index)

def quick_lomuto(items: list[int], left: int, right: int):

    if left < right:
        split_index = lomuto_partition(items, left, right)

        quick_lomuto(items, left, split_index - 1)
        quick_lomuto(items, split_index + 1, right)

    return items

def quick_sort(items: list[int]):
    if len(items) > 1:
        pivot = items[0]
        left = []
        middle = [pivot]
        right = []

        for i in range(1, len(items)):
            item = items[i]
            if item < pivot:
                left.append(item)
            elif item > pivot:
                right.append(item)
            else:
                middle.append(item)

        left = quick_sort(left)
        right = quick_sort(right)
        return left + middle + right
    return items